// Code generated - DO NOT EDIT.
// This file is a generated binding and any manual changes will be lost.

package contract

import (
	"math/big"
	"strings"

	ethereum "github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/event"
)

// Reference imports to suppress errors if they are not otherwise used.
var (
	_ = big.NewInt
	_ = strings.NewReader
	_ = ethereum.NotFound
	_ = abi.U256
	_ = bind.Bind
	_ = common.Big1
	_ = types.BloomLookup
	_ = event.NewSubscription
)

// CSTokenABI is the input ABI used to generate the binding from.
const CSTokenABI = "[{\"constant\":false,\"inputs\":[],\"name\":\"allAgingTimesAdded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"mintedAmount\",\"type\":\"uint256\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"calculateDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowManuallyBurnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_disable\",\"type\":\"bool\"}],\"name\":\"disableManuallyBurnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"addAgingTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"accountBalance\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addressByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"agingBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"poolAddress\",\"type\":\"address\"},{\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"addAgingTimesForPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countAddresses\",\"outputs\":[{\"name\":\"length\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"agingTime\",\"type\":\"uint256\"}],\"name\":\"AgingTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Issuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Destruction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"NewSmartToken\",\"type\":\"event\"}]"

// CSTokenFuncSigs maps the 4-byte function signature to its string representation.
var CSTokenFuncSigs = map[string]string{
	"d294cb0f": "accountBalance(address)",
	"8d37f52c": "addAgingTime(uint256)",
	"ea6ca182": "addAgingTimesForPool(address,uint256)",
	"d8ab9208": "addressByIndex(uint256)",
	"e27f0236": "agingBalanceOf(address,uint256)",
	"037ca6c4": "allAgingTimesAdded()",
	"30762e2e": "allowManuallyBurnTokens()",
	"dd62ed3e": "allowance(address,address)",
	"095ea7b3": "approve(address,uint256)",
	"cae9ca51": "approveAndCall(address,uint256,bytes)",
	"70a08231": "balanceOf(address)",
	"42966c68": "burn(uint256)",
	"2cf86006": "calculateDividends(uint256)",
	"a6f9dae1": "changeOwner(address)",
	"ec530de6": "countAddresses()",
	"313ce567": "decimals()",
	"a24835d1": "destroy(address,uint256)",
	"71766ae3": "disableManuallyBurnTokens(bool)",
	"1608f18f": "disableTransfers(bool)",
	"867904b4": "issue(address,uint256)",
	"23a36d2b": "mintToken(address,uint256,uint256)",
	"06fdde03": "name()",
	"8da5cb5b": "owner()",
	"79fc4687": "receiveDividends()",
	"5a3b7e42": "standard()",
	"95d89b41": "symbol()",
	"18160ddd": "totalSupply()",
	"a9059cbb": "transfer(address,uint256)",
	"23b872dd": "transferFrom(address,address,uint256)",
	"bef97c87": "transfersEnabled()",
}

// CSTokenBin is the compiled bytecode used for deploying new contracts.
var CSTokenBin = "0x60c0604052600960808190527f546f6b656e20302e31000000000000000000000000000000000000000000000060a090815262000040916001919062000ca4565b506040805180820190915260088082527f4b69636b436f696e0000000000000000000000000000000000000000000000006020909201918252620000879160029162000ca4565b506040805180820190915260048082527f4b49434b000000000000000000000000000000000000000000000000000000006020909201918252620000ce9160039162000ca4565b5060048054600860ff199182161790915560006005556006805482166001908117909155600f805461ffff191682179055601180549092161761ff00191690553480156200011b57600080fd5b50336000806101000a815481600160a060020a030219169083600160a060020a03160217905550336000806101000a815481600160a060020a030219169083600160a060020a03160217905550600a6060604051908101604052806000815260200160008152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a6060604051908101604052806359f83b908152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635a1fc890815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635a48a7108152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635a718590815260200160058152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635a966f908152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635abf4e10815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635ae6db108152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635b0fb990815260200160328152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635b3746908152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635b602510815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635b8903908152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635bb09090815260200160058152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635bd96f108152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635c00fc10815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635c29da908152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635c52b9108152602001603c8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635c77a3108152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635ca08190815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635cc80e908152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635cf12550815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635d187a108152602001601e8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635d415890815260200160148152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635d6a37108152602001600a8152602001600081525090806001815401808255809150509060018203906000526020600020906003020160009091929091909150600082015181600001556020820151816001015560408201518160020155505050600a606060405190810160405280635d91c4108152602001600581526020016000815250908060018154018082558091505090600182039060005260206000209060030201600090919290919091506000820151816000015560208201518160010155604082015181600201555050507ff4cd1f8571e8d9c97ffcb81558807ab73f9803d54de5da6a0420593c82a4a9f0306040518082600160a060020a0316600160a060020a0316815260200191505060405180910390a162000d49565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1062000ce757805160ff191683800117855562000d17565b8280016001018555821562000d17579182015b8281111562000d1757825182559160200191906001019062000cfa565b5062000d2592915062000d29565b5090565b62000d4691905b8082111562000d25576000815560010162000d30565b90565b6119cf8062000d596000396000f30060806040526004361061017f5763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663037ca6c4811461019157806306fdde03146101a8578063095ea7b3146102325780631608f18f1461026a57806318160ddd1461028457806323a36d2b146102ab57806323b872dd146102d25780632cf86006146102fc57806330762e2e14610314578063313ce5671461032957806342966c68146103545780635a3b7e421461036c57806370a082311461038157806371766ae3146103a257806379fc4687146103bc578063867904b4146103d15780638d37f52c146103f55780638da5cb5b1461040d57806395d89b411461043e578063a24835d114610453578063a6f9dae114610477578063a9059cbb14610498578063bef97c87146104bc578063cae9ca51146104d1578063d294cb0f1461053a578063d8ab92081461055b578063dd62ed3e14610573578063e27f02361461059a578063ea6ca182146105be578063ec530de6146105e2575b34801561018b57600080fd5b50600080fd5b34801561019d57600080fd5b506101a66105f7565b005b3480156101b457600080fd5b506101bd61061f565b6040805160208082528351818301528351919283929083019185019080838360005b838110156101f75781810151838201526020016101df565b50505050905090810190601f1680156102245780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b34801561023e57600080fd5b50610256600160a060020a03600435166024356106aa565b604080519115158252519081900360200190f35b34801561027657600080fd5b506101a66004351515610710565b34801561029057600080fd5b50610299610739565b60408051918252519081900360200190f35b3480156102b757600080fd5b506101a6600160a060020a036004351660243560443561073f565b3480156102de57600080fd5b50610256600160a060020a0360043581169060243516604435610831565b34801561030857600080fd5b506101a6600435610a47565b34801561032057600080fd5b50610256610b8a565b34801561033557600080fd5b5061033e610b93565b6040805160ff9092168252519081900360200190f35b34801561036057600080fd5b50610256600435610b9c565b34801561037857600080fd5b506101bd610be6565b34801561038d57600080fd5b50610299600160a060020a0360043516610c40565b3480156103ae57600080fd5b506101a66004351515610c5b565b3480156103c857600080fd5b506101a6610c84565b3480156103dd57600080fd5b506101a6600160a060020a0360043516602435610cca565b34801561040157600080fd5b506101a6600435610dc9565b34801561041957600080fd5b50610422610e2a565b60408051600160a060020a039092168252519081900360200190f35b34801561044a57600080fd5b506101bd610e39565b34801561045f57600080fd5b506101a6600160a060020a0360043516602435610e94565b34801561048357600080fd5b506101a6600160a060020a0360043516610f9d565b3480156104a457600080fd5b50610256600160a060020a0360043516602435610fe3565b3480156104c857600080fd5b5061025661115b565b3480156104dd57600080fd5b50604080516020600460443581810135601f8101849004840285018401909552848452610256948235600160a060020a03169460248035953695946064949201919081908401838280828437509497506111649650505050505050565b34801561054657600080fd5b50610299600160a060020a036004351661127d565b34801561056757600080fd5b506104226004356112b9565b34801561057f57600080fd5b50610299600160a060020a03600435811690602435166112e1565b3480156105a657600080fd5b50610299600160a060020a036004351660243561130c565b3480156105ca57600080fd5b506101a6600160a060020a0360043516602435611329565b3480156105ee57600080fd5b5061029961135c565b600054600160a060020a0316331461060e57600080fd5b6011805461ff001916610100179055565b6002805460408051602060018416156101000260001901909316849004601f810184900484028201840190925281815292918301828280156106a25780601f10610677576101008083540402835291602001916106a2565b820191906000526020600020905b81548152906001019060200180831161068557829003601f168201915b505050505081565b336000818152600b60209081526040808320600160a060020a038716808552908352818420869055815186815291519394909390927f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925928290030190a350600192915050565b600054600160a060020a0316331461072757600080fd5b6011805460ff19169115919091179055565b60055490565b600054600160a060020a0316331461075657600080fd5b428111156107765760005461077690600160a060020a0316848385611362565b600160a060020a0383166000908152600760205260409020546107999083611434565b600160a060020a0384166000908152600760205260409020556005546107bf9083611434565b6005556040805183815290517f9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc39181900360200190a16107fe8361144a565b604080518381529051600160a060020a0385169130916000805160206119848339815191529181900360200190a3505050565b60115460009060ff16151561084257fe5b61084b846114e2565b600a54600f5461ffff161080156108895750600f54600a8054909161ffff1690811061087357fe5b9060005260206000209060030201600001544210155b156108a35761089784611607565b506108a183611607565b505b816108ad8561127d565b10156108b857600080fd5b600160a060020a0384166000908152600b602090815260408083203384529091529020548211156108e857600080fd5b600160a060020a03841660009081526007602052604090205461090b9083611971565b600160a060020a03808616600090815260076020526040808220939093559085168152205461093a9083611434565b600160a060020a038085166000908152600760209081526040808320949094559187168152600b825282812033825290915220546109789083611971565b600160a060020a0385166000818152600b60209081526040808320338452825280832094909455918152600e909152908120541180156109cf5750600160a060020a0384166000908152600e602052604090205442105b156109fb57600160a060020a0384166000908152600e60205260409020546109fb908590859085611362565b610a048361144a565b82600160a060020a031684600160a060020a0316600080516020611984833981519152846040518082815260200191505060405180910390a35060019392505050565b600f54600a805460009261ffff16908110610a5e57fe5b6000918252602090912060039091020154421015610a7b57600080fd5b60008211610a8857600080fd5b600f54600a8054610ab89261ffff16908110610aa057fe5b90600052602060002090600302016002015483611434565b600c54909250821115610acb57600c5491505b600f54600a8054909161ffff16908110610ae157fe5b90600052602060002090600302016002015490505b81811015610b3357610b2a600c82815481101515610b1057fe5b600091825260209091200154600160a060020a0316611607565b50600101610af6565b600c54821415610b5a57600f805461ffff8082166001011661ffff19909116179055610b86565b600f54600a8054849261ffff16908110610b7057fe5b9060005260206000209060030201600201819055505b5050565b60065460ff1681565b60045460ff1681565b6000610ba83383610e94565b60408051838152905133917fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5919081900360200190a2506001919050565b60018054604080516020600284861615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156106a25780601f10610677576101008083540402835291602001916106a2565b600160a060020a031660009081526007602052604090205490565b600054600160a060020a03163314610c7257600080fd5b6006805460ff19169115919091179055565b600f54600a8054909161ffff16908110610c9a57fe5b6000918252602090912060039091020154421015610cb757600080fd5b610cc033611607565b1515610cc857fe5b565b600054600160a060020a03163314610ce157600080fd5b81600160a060020a0381161515610cf757600080fd5b82600160a060020a038116301415610d0e57600080fd5b610d1a60055484611434565b600555600160a060020a038416600090815260076020526040902054610d409084611434565b600160a060020a038516600090815260076020526040902055610d628461144a565b6040805184815290517f9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc39181900360200190a1604080518481529051600160a060020a0386169130916000805160206119848339815191529181900360200190a350505050565b600054600160a060020a03163314610de057600080fd5b601154610100900460ff1615610df557600080fd5b600980546001810182556000919091527f6e1540171b6c0c960b71a7020d9f60077f6af931a8bbf590da0223dacf75c7af0155565b600054600160a060020a031681565b6003805460408051602060026001851615610100026000190190941693909304601f810184900484028201840190925281815292918301828280156106a25780601f10610677576101008083540402835291602001916106a2565b610e9d826114e2565b33600160a060020a038316148015610eb7575060065460ff165b80610ecc5750600054600160a060020a031633145b1515610ed757600080fd5b80610ee18361127d565b1015610eec57600080fd5b600160a060020a038216600090815260076020526040902054610f0f9082611971565b600160a060020a038316600090815260076020526040902055600554610f359082611971565b6005556040805182815290513091600160a060020a038516916000805160206119848339815191529181900360200190a36040805182815290517f9a1b418bc061a5d80270261562e6986a35d995f8051145f277be16103abd34539181900360200190a15050565b600054600160a060020a03163314610fb457600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff1916600160a060020a0392909216919091179055565b60115460009060ff161515610ff457fe5b610ffd336114e2565b600a54600f5461ffff1610801561103b5750600f54600a8054909161ffff1690811061102557fe5b9060005260206000209060030201600001544210155b156110555761104933611607565b5061105383611607565b505b8161105f3361127d565b101561106a57600080fd5b336000908152600760205260409020546110849083611971565b33600090815260076020908152604080832093909355600e9052908120541180156110bd5750336000908152600e602052604090205442105b156110df57336000818152600e60205260409020546110df9190859085611362565b600160a060020a0383166000908152600760205260409020546111029083611434565b600160a060020a0384166000908152600760205260409020556111248361144a565b604080518381529051600160a060020a0385169133916000805160206119848339815191529181900360200190a350600192915050565b60115460ff1681565b60008361117181856106aa565b15611275576040517f8f4ffcb10000000000000000000000000000000000000000000000000000000081523360048201818152602483018790523060448401819052608060648501908152875160848601528751600160a060020a03871695638f4ffcb195948b94938b939192909160a490910190602085019080838360005b838110156112095781810151838201526020016111f1565b50505050905090810190601f1680156112365780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b15801561125857600080fd5b505af115801561126c573d6000803e3d6000fd5b50505050600191505b509392505050565b600160a060020a038116600090815260076020908152604080832054600883528184208480529092528220546112b39190611971565b92915050565b600c8054829081106112c757fe5b600091825260209091200154600160a060020a0316905081565b600160a060020a039182166000908152600b6020908152604080832093909416825291909152205490565b600860209081526000928352604080842090915290825290205481565b600054600160a060020a0316331461134057600080fd5b600160a060020a039091166000908152600e6020526040902055565b600c5490565b600160a060020a03831660009081526008602090815260408083208380529091529020546113909082611434565b600160a060020a03841660009081526008602090815260408083208380529091528082209290925583815220546113c79082611434565b600160a060020a03808516600081815260086020908152604080832088845282529182902094909455805185815293840186905280519193928816927f46a1749a7648b704d1ad3fe33741b13174a4b1641db362e808d00eab7250d106929081900390910190a350505050565b60008282018381101561144357fe5b9392505050565b600160a060020a0381166000908152600d602052604090205460ff1615156114df57600160a060020a0381166000818152600d60205260408120805460ff19166001908117909155600c805491820181559091527fdf6966c971051c3d54ec59162606531493a51404a002842f56009d7e5cf4a8c701805473ffffffffffffffffffffffffffffffffffffffff191690911790555b50565b600160a060020a0381166000908152600860209081526040808320838052909152812054151561151157610b86565b5060005b600954811015610b86574260098281548110151561152f57fe5b906000526020600020015410156115ff57600160a060020a0382166000818152600860208181526040808420848052808352908420549484529190526009805461159f949391908690811061158057fe5b9060005260206000200154815260200190815260200160002054611971565b600160a060020a03831660008181526008602081815260408084208480528083529084209590955592825290915260098054919291839190859081106115e157fe5b90600052602060002001548152602001908152602001600020819055505b600101611515565b600f54600160a060020a03821660009081526010602052604081205490918291829161ffff161161163b576000925061196a565b600f54600a80546103e89261ffff1690811061165357fe5b9060005260206000209060030201600101546007600087600160a060020a0316600160a060020a03168152602001908152602001600020540281151561169557fe5b600160a060020a03861660009081526007602052604090205491900492506116bd9083611434565b600160a060020a0385166000818152600760209081526040918290209390935580518581529051919230926000805160206119848339815191529281900390910190a36040805183815290517f9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc39181900360200190a161173f60055483611434565b600555600160a060020a0384166000908152600860209081526040808320838052909152812054111561194257600160a060020a0384166000908152600860209081526040808320838052909152902054600f54600a80546117f593926103e8929161ffff9091169081106117b057fe5b6000918252602080832060016003909302019190910154600160a060020a038a168352600882526040808420848052909252912054028115156117ef57fe5b04611434565b600160a060020a038516600090815260086020908152604080832083805290915281209190915590505b60095481101561194257600160a060020a0384166000908152600860205260408120600980546118f59391908590811061185557fe5b60009182526020808320909101548352820192909252604001902054600f54600a80546103e89261ffff1690811061188957fe5b9060005260206000209060030201600101546008600089600160a060020a0316600160a060020a0316815260200190815260200160002060006009878154811015156118d157fe5b9060005260206000200154815260200190815260200160002054028115156117ef57fe5b600160a060020a0385166000908152600860205260408120600980549192918590811061191e57fe5b6000918252602080832090910154835282019290925260400190205560010161181f565b600f54600160a060020a038516600090815260106020526040902061ffff9091169055600192505b5050919050565b60008183101561197d57fe5b509003905600ddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3efa165627a7a72305820f9be184eea17a072fc5a746359fd05429fbb557937627bb0804848202669987a0029"

// DeployCSToken deploys a new Ethereum contract, binding an instance of CSToken to it.
func DeployCSToken(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *CSToken, error) {
	parsed, err := abi.JSON(strings.NewReader(CSTokenABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(CSTokenBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &CSToken{CSTokenCaller: CSTokenCaller{contract: contract}, CSTokenTransactor: CSTokenTransactor{contract: contract}, CSTokenFilterer: CSTokenFilterer{contract: contract}}, nil
}

// CSToken is an auto generated Go binding around an Ethereum contract.
type CSToken struct {
	CSTokenCaller     // Read-only binding to the contract
	CSTokenTransactor // Write-only binding to the contract
	CSTokenFilterer   // Log filterer for contract events
}

// CSTokenCaller is an auto generated read-only Go binding around an Ethereum contract.
type CSTokenCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CSTokenTransactor is an auto generated write-only Go binding around an Ethereum contract.
type CSTokenTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CSTokenFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type CSTokenFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// CSTokenSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type CSTokenSession struct {
	Contract     *CSToken          // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// CSTokenCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type CSTokenCallerSession struct {
	Contract *CSTokenCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts  // Call options to use throughout this session
}

// CSTokenTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type CSTokenTransactorSession struct {
	Contract     *CSTokenTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts  // Transaction auth options to use throughout this session
}

// CSTokenRaw is an auto generated low-level Go binding around an Ethereum contract.
type CSTokenRaw struct {
	Contract *CSToken // Generic contract binding to access the raw methods on
}

// CSTokenCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type CSTokenCallerRaw struct {
	Contract *CSTokenCaller // Generic read-only contract binding to access the raw methods on
}

// CSTokenTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type CSTokenTransactorRaw struct {
	Contract *CSTokenTransactor // Generic write-only contract binding to access the raw methods on
}

// NewCSToken creates a new instance of CSToken, bound to a specific deployed contract.
func NewCSToken(address common.Address, backend bind.ContractBackend) (*CSToken, error) {
	contract, err := bindCSToken(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &CSToken{CSTokenCaller: CSTokenCaller{contract: contract}, CSTokenTransactor: CSTokenTransactor{contract: contract}, CSTokenFilterer: CSTokenFilterer{contract: contract}}, nil
}

// NewCSTokenCaller creates a new read-only instance of CSToken, bound to a specific deployed contract.
func NewCSTokenCaller(address common.Address, caller bind.ContractCaller) (*CSTokenCaller, error) {
	contract, err := bindCSToken(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &CSTokenCaller{contract: contract}, nil
}

// NewCSTokenTransactor creates a new write-only instance of CSToken, bound to a specific deployed contract.
func NewCSTokenTransactor(address common.Address, transactor bind.ContractTransactor) (*CSTokenTransactor, error) {
	contract, err := bindCSToken(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &CSTokenTransactor{contract: contract}, nil
}

// NewCSTokenFilterer creates a new log filterer instance of CSToken, bound to a specific deployed contract.
func NewCSTokenFilterer(address common.Address, filterer bind.ContractFilterer) (*CSTokenFilterer, error) {
	contract, err := bindCSToken(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &CSTokenFilterer{contract: contract}, nil
}

// bindCSToken binds a generic wrapper to an already deployed contract.
func bindCSToken(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(CSTokenABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CSToken *CSTokenRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CSToken.Contract.CSTokenCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CSToken *CSTokenRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CSToken.Contract.CSTokenTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CSToken *CSTokenRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CSToken.Contract.CSTokenTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_CSToken *CSTokenCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _CSToken.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_CSToken *CSTokenTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CSToken.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_CSToken *CSTokenTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _CSToken.Contract.contract.Transact(opts, method, params...)
}

// AccountBalance is a free data retrieval call binding the contract method 0xd294cb0f.
//
// Solidity: function accountBalance(address _address) constant returns(uint256 balance)
func (_CSToken *CSTokenCaller) AccountBalance(opts *bind.CallOpts, _address common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "accountBalance", _address)
	return *ret0, err
}

// AccountBalance is a free data retrieval call binding the contract method 0xd294cb0f.
//
// Solidity: function accountBalance(address _address) constant returns(uint256 balance)
func (_CSToken *CSTokenSession) AccountBalance(_address common.Address) (*big.Int, error) {
	return _CSToken.Contract.AccountBalance(&_CSToken.CallOpts, _address)
}

// AccountBalance is a free data retrieval call binding the contract method 0xd294cb0f.
//
// Solidity: function accountBalance(address _address) constant returns(uint256 balance)
func (_CSToken *CSTokenCallerSession) AccountBalance(_address common.Address) (*big.Int, error) {
	return _CSToken.Contract.AccountBalance(&_CSToken.CallOpts, _address)
}

// AddressByIndex is a free data retrieval call binding the contract method 0xd8ab9208.
//
// Solidity: function addressByIndex(uint256 ) constant returns(address)
func (_CSToken *CSTokenCaller) AddressByIndex(opts *bind.CallOpts, arg0 *big.Int) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "addressByIndex", arg0)
	return *ret0, err
}

// AddressByIndex is a free data retrieval call binding the contract method 0xd8ab9208.
//
// Solidity: function addressByIndex(uint256 ) constant returns(address)
func (_CSToken *CSTokenSession) AddressByIndex(arg0 *big.Int) (common.Address, error) {
	return _CSToken.Contract.AddressByIndex(&_CSToken.CallOpts, arg0)
}

// AddressByIndex is a free data retrieval call binding the contract method 0xd8ab9208.
//
// Solidity: function addressByIndex(uint256 ) constant returns(address)
func (_CSToken *CSTokenCallerSession) AddressByIndex(arg0 *big.Int) (common.Address, error) {
	return _CSToken.Contract.AddressByIndex(&_CSToken.CallOpts, arg0)
}

// AgingBalanceOf is a free data retrieval call binding the contract method 0xe27f0236.
//
// Solidity: function agingBalanceOf(address , uint256 ) constant returns(uint256)
func (_CSToken *CSTokenCaller) AgingBalanceOf(opts *bind.CallOpts, arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "agingBalanceOf", arg0, arg1)
	return *ret0, err
}

// AgingBalanceOf is a free data retrieval call binding the contract method 0xe27f0236.
//
// Solidity: function agingBalanceOf(address , uint256 ) constant returns(uint256)
func (_CSToken *CSTokenSession) AgingBalanceOf(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _CSToken.Contract.AgingBalanceOf(&_CSToken.CallOpts, arg0, arg1)
}

// AgingBalanceOf is a free data retrieval call binding the contract method 0xe27f0236.
//
// Solidity: function agingBalanceOf(address , uint256 ) constant returns(uint256)
func (_CSToken *CSTokenCallerSession) AgingBalanceOf(arg0 common.Address, arg1 *big.Int) (*big.Int, error) {
	return _CSToken.Contract.AgingBalanceOf(&_CSToken.CallOpts, arg0, arg1)
}

// AllowManuallyBurnTokens is a free data retrieval call binding the contract method 0x30762e2e.
//
// Solidity: function allowManuallyBurnTokens() constant returns(bool)
func (_CSToken *CSTokenCaller) AllowManuallyBurnTokens(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "allowManuallyBurnTokens")
	return *ret0, err
}

// AllowManuallyBurnTokens is a free data retrieval call binding the contract method 0x30762e2e.
//
// Solidity: function allowManuallyBurnTokens() constant returns(bool)
func (_CSToken *CSTokenSession) AllowManuallyBurnTokens() (bool, error) {
	return _CSToken.Contract.AllowManuallyBurnTokens(&_CSToken.CallOpts)
}

// AllowManuallyBurnTokens is a free data retrieval call binding the contract method 0x30762e2e.
//
// Solidity: function allowManuallyBurnTokens() constant returns(bool)
func (_CSToken *CSTokenCallerSession) AllowManuallyBurnTokens() (bool, error) {
	return _CSToken.Contract.AllowManuallyBurnTokens(&_CSToken.CallOpts)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address _owner, address _spender) constant returns(uint256 remaining)
func (_CSToken *CSTokenCaller) Allowance(opts *bind.CallOpts, _owner common.Address, _spender common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "allowance", _owner, _spender)
	return *ret0, err
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address _owner, address _spender) constant returns(uint256 remaining)
func (_CSToken *CSTokenSession) Allowance(_owner common.Address, _spender common.Address) (*big.Int, error) {
	return _CSToken.Contract.Allowance(&_CSToken.CallOpts, _owner, _spender)
}

// Allowance is a free data retrieval call binding the contract method 0xdd62ed3e.
//
// Solidity: function allowance(address _owner, address _spender) constant returns(uint256 remaining)
func (_CSToken *CSTokenCallerSession) Allowance(_owner common.Address, _spender common.Address) (*big.Int, error) {
	return _CSToken.Contract.Allowance(&_CSToken.CallOpts, _owner, _spender)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 balance)
func (_CSToken *CSTokenCaller) BalanceOf(opts *bind.CallOpts, _owner common.Address) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "balanceOf", _owner)
	return *ret0, err
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 balance)
func (_CSToken *CSTokenSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _CSToken.Contract.BalanceOf(&_CSToken.CallOpts, _owner)
}

// BalanceOf is a free data retrieval call binding the contract method 0x70a08231.
//
// Solidity: function balanceOf(address _owner) constant returns(uint256 balance)
func (_CSToken *CSTokenCallerSession) BalanceOf(_owner common.Address) (*big.Int, error) {
	return _CSToken.Contract.BalanceOf(&_CSToken.CallOpts, _owner)
}

// CountAddresses is a free data retrieval call binding the contract method 0xec530de6.
//
// Solidity: function countAddresses() constant returns(uint256 length)
func (_CSToken *CSTokenCaller) CountAddresses(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "countAddresses")
	return *ret0, err
}

// CountAddresses is a free data retrieval call binding the contract method 0xec530de6.
//
// Solidity: function countAddresses() constant returns(uint256 length)
func (_CSToken *CSTokenSession) CountAddresses() (*big.Int, error) {
	return _CSToken.Contract.CountAddresses(&_CSToken.CallOpts)
}

// CountAddresses is a free data retrieval call binding the contract method 0xec530de6.
//
// Solidity: function countAddresses() constant returns(uint256 length)
func (_CSToken *CSTokenCallerSession) CountAddresses() (*big.Int, error) {
	return _CSToken.Contract.CountAddresses(&_CSToken.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() constant returns(uint8)
func (_CSToken *CSTokenCaller) Decimals(opts *bind.CallOpts) (uint8, error) {
	var (
		ret0 = new(uint8)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "decimals")
	return *ret0, err
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() constant returns(uint8)
func (_CSToken *CSTokenSession) Decimals() (uint8, error) {
	return _CSToken.Contract.Decimals(&_CSToken.CallOpts)
}

// Decimals is a free data retrieval call binding the contract method 0x313ce567.
//
// Solidity: function decimals() constant returns(uint8)
func (_CSToken *CSTokenCallerSession) Decimals() (uint8, error) {
	return _CSToken.Contract.Decimals(&_CSToken.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_CSToken *CSTokenCaller) Name(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "name")
	return *ret0, err
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_CSToken *CSTokenSession) Name() (string, error) {
	return _CSToken.Contract.Name(&_CSToken.CallOpts)
}

// Name is a free data retrieval call binding the contract method 0x06fdde03.
//
// Solidity: function name() constant returns(string)
func (_CSToken *CSTokenCallerSession) Name() (string, error) {
	return _CSToken.Contract.Name(&_CSToken.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_CSToken *CSTokenCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_CSToken *CSTokenSession) Owner() (common.Address, error) {
	return _CSToken.Contract.Owner(&_CSToken.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_CSToken *CSTokenCallerSession) Owner() (common.Address, error) {
	return _CSToken.Contract.Owner(&_CSToken.CallOpts)
}

// Standard is a free data retrieval call binding the contract method 0x5a3b7e42.
//
// Solidity: function standard() constant returns(string)
func (_CSToken *CSTokenCaller) Standard(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "standard")
	return *ret0, err
}

// Standard is a free data retrieval call binding the contract method 0x5a3b7e42.
//
// Solidity: function standard() constant returns(string)
func (_CSToken *CSTokenSession) Standard() (string, error) {
	return _CSToken.Contract.Standard(&_CSToken.CallOpts)
}

// Standard is a free data retrieval call binding the contract method 0x5a3b7e42.
//
// Solidity: function standard() constant returns(string)
func (_CSToken *CSTokenCallerSession) Standard() (string, error) {
	return _CSToken.Contract.Standard(&_CSToken.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_CSToken *CSTokenCaller) Symbol(opts *bind.CallOpts) (string, error) {
	var (
		ret0 = new(string)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "symbol")
	return *ret0, err
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_CSToken *CSTokenSession) Symbol() (string, error) {
	return _CSToken.Contract.Symbol(&_CSToken.CallOpts)
}

// Symbol is a free data retrieval call binding the contract method 0x95d89b41.
//
// Solidity: function symbol() constant returns(string)
func (_CSToken *CSTokenCallerSession) Symbol() (string, error) {
	return _CSToken.Contract.Symbol(&_CSToken.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256 totalSupply)
func (_CSToken *CSTokenCaller) TotalSupply(opts *bind.CallOpts) (*big.Int, error) {
	var (
		ret0 = new(*big.Int)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "totalSupply")
	return *ret0, err
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256 totalSupply)
func (_CSToken *CSTokenSession) TotalSupply() (*big.Int, error) {
	return _CSToken.Contract.TotalSupply(&_CSToken.CallOpts)
}

// TotalSupply is a free data retrieval call binding the contract method 0x18160ddd.
//
// Solidity: function totalSupply() constant returns(uint256 totalSupply)
func (_CSToken *CSTokenCallerSession) TotalSupply() (*big.Int, error) {
	return _CSToken.Contract.TotalSupply(&_CSToken.CallOpts)
}

// TransfersEnabled is a free data retrieval call binding the contract method 0xbef97c87.
//
// Solidity: function transfersEnabled() constant returns(bool)
func (_CSToken *CSTokenCaller) TransfersEnabled(opts *bind.CallOpts) (bool, error) {
	var (
		ret0 = new(bool)
	)
	out := ret0
	err := _CSToken.contract.Call(opts, out, "transfersEnabled")
	return *ret0, err
}

// TransfersEnabled is a free data retrieval call binding the contract method 0xbef97c87.
//
// Solidity: function transfersEnabled() constant returns(bool)
func (_CSToken *CSTokenSession) TransfersEnabled() (bool, error) {
	return _CSToken.Contract.TransfersEnabled(&_CSToken.CallOpts)
}

// TransfersEnabled is a free data retrieval call binding the contract method 0xbef97c87.
//
// Solidity: function transfersEnabled() constant returns(bool)
func (_CSToken *CSTokenCallerSession) TransfersEnabled() (bool, error) {
	return _CSToken.Contract.TransfersEnabled(&_CSToken.CallOpts)
}

// AddAgingTime is a paid mutator transaction binding the contract method 0x8d37f52c.
//
// Solidity: function addAgingTime(uint256 time) returns()
func (_CSToken *CSTokenTransactor) AddAgingTime(opts *bind.TransactOpts, time *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "addAgingTime", time)
}

// AddAgingTime is a paid mutator transaction binding the contract method 0x8d37f52c.
//
// Solidity: function addAgingTime(uint256 time) returns()
func (_CSToken *CSTokenSession) AddAgingTime(time *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.AddAgingTime(&_CSToken.TransactOpts, time)
}

// AddAgingTime is a paid mutator transaction binding the contract method 0x8d37f52c.
//
// Solidity: function addAgingTime(uint256 time) returns()
func (_CSToken *CSTokenTransactorSession) AddAgingTime(time *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.AddAgingTime(&_CSToken.TransactOpts, time)
}

// AddAgingTimesForPool is a paid mutator transaction binding the contract method 0xea6ca182.
//
// Solidity: function addAgingTimesForPool(address poolAddress, uint256 agingTime) returns()
func (_CSToken *CSTokenTransactor) AddAgingTimesForPool(opts *bind.TransactOpts, poolAddress common.Address, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "addAgingTimesForPool", poolAddress, agingTime)
}

// AddAgingTimesForPool is a paid mutator transaction binding the contract method 0xea6ca182.
//
// Solidity: function addAgingTimesForPool(address poolAddress, uint256 agingTime) returns()
func (_CSToken *CSTokenSession) AddAgingTimesForPool(poolAddress common.Address, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.AddAgingTimesForPool(&_CSToken.TransactOpts, poolAddress, agingTime)
}

// AddAgingTimesForPool is a paid mutator transaction binding the contract method 0xea6ca182.
//
// Solidity: function addAgingTimesForPool(address poolAddress, uint256 agingTime) returns()
func (_CSToken *CSTokenTransactorSession) AddAgingTimesForPool(poolAddress common.Address, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.AddAgingTimesForPool(&_CSToken.TransactOpts, poolAddress, agingTime)
}

// AllAgingTimesAdded is a paid mutator transaction binding the contract method 0x037ca6c4.
//
// Solidity: function allAgingTimesAdded() returns()
func (_CSToken *CSTokenTransactor) AllAgingTimesAdded(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "allAgingTimesAdded")
}

// AllAgingTimesAdded is a paid mutator transaction binding the contract method 0x037ca6c4.
//
// Solidity: function allAgingTimesAdded() returns()
func (_CSToken *CSTokenSession) AllAgingTimesAdded() (*types.Transaction, error) {
	return _CSToken.Contract.AllAgingTimesAdded(&_CSToken.TransactOpts)
}

// AllAgingTimesAdded is a paid mutator transaction binding the contract method 0x037ca6c4.
//
// Solidity: function allAgingTimesAdded() returns()
func (_CSToken *CSTokenTransactorSession) AllAgingTimesAdded() (*types.Transaction, error) {
	return _CSToken.Contract.AllAgingTimesAdded(&_CSToken.TransactOpts)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _spender, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactor) Approve(opts *bind.TransactOpts, _spender common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "approve", _spender, _value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _spender, uint256 _value) returns(bool success)
func (_CSToken *CSTokenSession) Approve(_spender common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Approve(&_CSToken.TransactOpts, _spender, _value)
}

// Approve is a paid mutator transaction binding the contract method 0x095ea7b3.
//
// Solidity: function approve(address _spender, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactorSession) Approve(_spender common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Approve(&_CSToken.TransactOpts, _spender, _value)
}

// ApproveAndCall is a paid mutator transaction binding the contract method 0xcae9ca51.
//
// Solidity: function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns(bool success)
func (_CSToken *CSTokenTransactor) ApproveAndCall(opts *bind.TransactOpts, _spender common.Address, _value *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "approveAndCall", _spender, _value, _extraData)
}

// ApproveAndCall is a paid mutator transaction binding the contract method 0xcae9ca51.
//
// Solidity: function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns(bool success)
func (_CSToken *CSTokenSession) ApproveAndCall(_spender common.Address, _value *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _CSToken.Contract.ApproveAndCall(&_CSToken.TransactOpts, _spender, _value, _extraData)
}

// ApproveAndCall is a paid mutator transaction binding the contract method 0xcae9ca51.
//
// Solidity: function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns(bool success)
func (_CSToken *CSTokenTransactorSession) ApproveAndCall(_spender common.Address, _value *big.Int, _extraData []byte) (*types.Transaction, error) {
	return _CSToken.Contract.ApproveAndCall(&_CSToken.TransactOpts, _spender, _value, _extraData)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactor) Burn(opts *bind.TransactOpts, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "burn", _value)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 _value) returns(bool success)
func (_CSToken *CSTokenSession) Burn(_value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Burn(&_CSToken.TransactOpts, _value)
}

// Burn is a paid mutator transaction binding the contract method 0x42966c68.
//
// Solidity: function burn(uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactorSession) Burn(_value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Burn(&_CSToken.TransactOpts, _value)
}

// CalculateDividends is a paid mutator transaction binding the contract method 0x2cf86006.
//
// Solidity: function calculateDividends(uint256 limit) returns()
func (_CSToken *CSTokenTransactor) CalculateDividends(opts *bind.TransactOpts, limit *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "calculateDividends", limit)
}

// CalculateDividends is a paid mutator transaction binding the contract method 0x2cf86006.
//
// Solidity: function calculateDividends(uint256 limit) returns()
func (_CSToken *CSTokenSession) CalculateDividends(limit *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.CalculateDividends(&_CSToken.TransactOpts, limit)
}

// CalculateDividends is a paid mutator transaction binding the contract method 0x2cf86006.
//
// Solidity: function calculateDividends(uint256 limit) returns()
func (_CSToken *CSTokenTransactorSession) CalculateDividends(limit *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.CalculateDividends(&_CSToken.TransactOpts, limit)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_CSToken *CSTokenTransactor) ChangeOwner(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "changeOwner", newOwner)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_CSToken *CSTokenSession) ChangeOwner(newOwner common.Address) (*types.Transaction, error) {
	return _CSToken.Contract.ChangeOwner(&_CSToken.TransactOpts, newOwner)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_CSToken *CSTokenTransactorSession) ChangeOwner(newOwner common.Address) (*types.Transaction, error) {
	return _CSToken.Contract.ChangeOwner(&_CSToken.TransactOpts, newOwner)
}

// Destroy is a paid mutator transaction binding the contract method 0xa24835d1.
//
// Solidity: function destroy(address _from, uint256 _amount) returns()
func (_CSToken *CSTokenTransactor) Destroy(opts *bind.TransactOpts, _from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "destroy", _from, _amount)
}

// Destroy is a paid mutator transaction binding the contract method 0xa24835d1.
//
// Solidity: function destroy(address _from, uint256 _amount) returns()
func (_CSToken *CSTokenSession) Destroy(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Destroy(&_CSToken.TransactOpts, _from, _amount)
}

// Destroy is a paid mutator transaction binding the contract method 0xa24835d1.
//
// Solidity: function destroy(address _from, uint256 _amount) returns()
func (_CSToken *CSTokenTransactorSession) Destroy(_from common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Destroy(&_CSToken.TransactOpts, _from, _amount)
}

// DisableManuallyBurnTokens is a paid mutator transaction binding the contract method 0x71766ae3.
//
// Solidity: function disableManuallyBurnTokens(bool _disable) returns()
func (_CSToken *CSTokenTransactor) DisableManuallyBurnTokens(opts *bind.TransactOpts, _disable bool) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "disableManuallyBurnTokens", _disable)
}

// DisableManuallyBurnTokens is a paid mutator transaction binding the contract method 0x71766ae3.
//
// Solidity: function disableManuallyBurnTokens(bool _disable) returns()
func (_CSToken *CSTokenSession) DisableManuallyBurnTokens(_disable bool) (*types.Transaction, error) {
	return _CSToken.Contract.DisableManuallyBurnTokens(&_CSToken.TransactOpts, _disable)
}

// DisableManuallyBurnTokens is a paid mutator transaction binding the contract method 0x71766ae3.
//
// Solidity: function disableManuallyBurnTokens(bool _disable) returns()
func (_CSToken *CSTokenTransactorSession) DisableManuallyBurnTokens(_disable bool) (*types.Transaction, error) {
	return _CSToken.Contract.DisableManuallyBurnTokens(&_CSToken.TransactOpts, _disable)
}

// DisableTransfers is a paid mutator transaction binding the contract method 0x1608f18f.
//
// Solidity: function disableTransfers(bool _disable) returns()
func (_CSToken *CSTokenTransactor) DisableTransfers(opts *bind.TransactOpts, _disable bool) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "disableTransfers", _disable)
}

// DisableTransfers is a paid mutator transaction binding the contract method 0x1608f18f.
//
// Solidity: function disableTransfers(bool _disable) returns()
func (_CSToken *CSTokenSession) DisableTransfers(_disable bool) (*types.Transaction, error) {
	return _CSToken.Contract.DisableTransfers(&_CSToken.TransactOpts, _disable)
}

// DisableTransfers is a paid mutator transaction binding the contract method 0x1608f18f.
//
// Solidity: function disableTransfers(bool _disable) returns()
func (_CSToken *CSTokenTransactorSession) DisableTransfers(_disable bool) (*types.Transaction, error) {
	return _CSToken.Contract.DisableTransfers(&_CSToken.TransactOpts, _disable)
}

// Issue is a paid mutator transaction binding the contract method 0x867904b4.
//
// Solidity: function issue(address _to, uint256 _amount) returns()
func (_CSToken *CSTokenTransactor) Issue(opts *bind.TransactOpts, _to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "issue", _to, _amount)
}

// Issue is a paid mutator transaction binding the contract method 0x867904b4.
//
// Solidity: function issue(address _to, uint256 _amount) returns()
func (_CSToken *CSTokenSession) Issue(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Issue(&_CSToken.TransactOpts, _to, _amount)
}

// Issue is a paid mutator transaction binding the contract method 0x867904b4.
//
// Solidity: function issue(address _to, uint256 _amount) returns()
func (_CSToken *CSTokenTransactorSession) Issue(_to common.Address, _amount *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Issue(&_CSToken.TransactOpts, _to, _amount)
}

// MintToken is a paid mutator transaction binding the contract method 0x23a36d2b.
//
// Solidity: function mintToken(address target, uint256 mintedAmount, uint256 agingTime) returns()
func (_CSToken *CSTokenTransactor) MintToken(opts *bind.TransactOpts, target common.Address, mintedAmount *big.Int, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "mintToken", target, mintedAmount, agingTime)
}

// MintToken is a paid mutator transaction binding the contract method 0x23a36d2b.
//
// Solidity: function mintToken(address target, uint256 mintedAmount, uint256 agingTime) returns()
func (_CSToken *CSTokenSession) MintToken(target common.Address, mintedAmount *big.Int, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.MintToken(&_CSToken.TransactOpts, target, mintedAmount, agingTime)
}

// MintToken is a paid mutator transaction binding the contract method 0x23a36d2b.
//
// Solidity: function mintToken(address target, uint256 mintedAmount, uint256 agingTime) returns()
func (_CSToken *CSTokenTransactorSession) MintToken(target common.Address, mintedAmount *big.Int, agingTime *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.MintToken(&_CSToken.TransactOpts, target, mintedAmount, agingTime)
}

// ReceiveDividends is a paid mutator transaction binding the contract method 0x79fc4687.
//
// Solidity: function receiveDividends() returns()
func (_CSToken *CSTokenTransactor) ReceiveDividends(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "receiveDividends")
}

// ReceiveDividends is a paid mutator transaction binding the contract method 0x79fc4687.
//
// Solidity: function receiveDividends() returns()
func (_CSToken *CSTokenSession) ReceiveDividends() (*types.Transaction, error) {
	return _CSToken.Contract.ReceiveDividends(&_CSToken.TransactOpts)
}

// ReceiveDividends is a paid mutator transaction binding the contract method 0x79fc4687.
//
// Solidity: function receiveDividends() returns()
func (_CSToken *CSTokenTransactorSession) ReceiveDividends() (*types.Transaction, error) {
	return _CSToken.Contract.ReceiveDividends(&_CSToken.TransactOpts)
}

// Transfer is a paid mutator transactionbinding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactor) Transfer(opts *bind.TransactOpts, _to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "transfer", _to, _value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenSession) Transfer(_to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Transfer(&_CSToken.TransactOpts, _to, _value)
}

// Transfer is a paid mutator transaction binding the contract method 0xa9059cbb.
//
// Solidity: function transfer(address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactorSession) Transfer(_to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.Transfer(&_CSToken.TransactOpts, _to, _value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactor) TransferFrom(opts *bind.TransactOpts, _from common.Address, _to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.contract.Transact(opts, "transferFrom", _from, _to, _value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenSession) TransferFrom(_from common.Address, _to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.TransferFrom(&_CSToken.TransactOpts, _from, _to, _value)
}

// TransferFrom is a paid mutator transaction binding the contract method 0x23b872dd.
//
// Solidity: function transferFrom(address _from, address _to, uint256 _value) returns(bool success)
func (_CSToken *CSTokenTransactorSession) TransferFrom(_from common.Address, _to common.Address, _value *big.Int) (*types.Transaction, error) {
	return _CSToken.Contract.TransferFrom(&_CSToken.TransactOpts, _from, _to, _value)
}

// CSTokenAgingTransferIterator is returned from FilterAgingTransfer and is used to iterate over the raw logs and unpacked data for AgingTransfer events raised by the CSToken contract.
type CSTokenAgingTransferIterator struct {
	Event *CSTokenAgingTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenAgingTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenAgingTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenAgingTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenAgingTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenAgingTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenAgingTransfer represents a AgingTransfer event raised by the CSToken contract.
type CSTokenAgingTransfer struct {
	From      common.Address
	To        common.Address
	Value     *big.Int
	AgingTime *big.Int
	Raw       types.Log // Blockchain specific contextual infos
}

// FilterAgingTransfer is a free log retrieval operation binding the contract event 0x46a1749a7648b704d1ad3fe33741b13174a4b1641db362e808d00eab7250d106.
//
// Solidity: event AgingTransfer(address indexed from, address indexed to, uint256 value, uint256 agingTime)
func (_CSToken *CSTokenFilterer) FilterAgingTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*CSTokenAgingTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "AgingTransfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &CSTokenAgingTransferIterator{contract: _CSToken.contract, event: "AgingTransfer", logs: logs, sub: sub}, nil
}

// WatchAgingTransfer is a free log subscription operation binding the contract event 0x46a1749a7648b704d1ad3fe33741b13174a4b1641db362e808d00eab7250d106.
//
// Solidity: event AgingTransfer(address indexed from, address indexed to, uint256 value, uint256 agingTime)
func (_CSToken *CSTokenFilterer) WatchAgingTransfer(opts *bind.WatchOpts, sink chan<- *CSTokenAgingTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "AgingTransfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenAgingTransfer)
				if err := _CSToken.contract.UnpackLog(event, "AgingTransfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseAgingTransfer is a log parse operation binding the contract event 0x46a1749a7648b704d1ad3fe33741b13174a4b1641db362e808d00eab7250d106.
//
// Solidity: event AgingTransfer(address indexed from, address indexed to, uint256 value, uint256 agingTime)
func (_CSToken *CSTokenFilterer) ParseAgingTransfer(log types.Log) (*CSTokenAgingTransfer, error) {
	event := new(CSTokenAgingTransfer)
	if err := _CSToken.contract.UnpackLog(event, "AgingTransfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenApprovalIterator is returned from FilterApproval and is used to iterate over the raw logs and unpacked data for Approval events raised by the CSToken contract.
type CSTokenApprovalIterator struct {
	Event *CSTokenApproval // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenApprovalIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenApproval)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenApproval)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenApprovalIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenApprovalIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenApproval represents a Approval event raised by the CSToken contract.
type CSTokenApproval struct {
	Owner   common.Address
	Spender common.Address
	Value   *big.Int
	Raw     types.Log // Blockchain specific contextual infos
}

// FilterApproval is a free log retrieval operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _spender, uint256 _value)
func (_CSToken *CSTokenFilterer) FilterApproval(opts *bind.FilterOpts, _owner []common.Address, _spender []common.Address) (*CSTokenApprovalIterator, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _spenderRule []interface{}
	for _, _spenderItem := range _spender {
		_spenderRule = append(_spenderRule, _spenderItem)
	}

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "Approval", _ownerRule, _spenderRule)
	if err != nil {
		return nil, err
	}
	return &CSTokenApprovalIterator{contract: _CSToken.contract, event: "Approval", logs: logs, sub: sub}, nil
}

// WatchApproval is a free log subscription operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _spender, uint256 _value)
func (_CSToken *CSTokenFilterer) WatchApproval(opts *bind.WatchOpts, sink chan<- *CSTokenApproval, _owner []common.Address, _spender []common.Address) (event.Subscription, error) {

	var _ownerRule []interface{}
	for _, _ownerItem := range _owner {
		_ownerRule = append(_ownerRule, _ownerItem)
	}
	var _spenderRule []interface{}
	for _, _spenderItem := range _spender {
		_spenderRule = append(_spenderRule, _spenderItem)
	}

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "Approval", _ownerRule, _spenderRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenApproval)
				if err := _CSToken.contract.UnpackLog(event, "Approval", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseApproval is a log parse operation binding the contract event 0x8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925.
//
// Solidity: event Approval(address indexed _owner, address indexed _spender, uint256 _value)
func (_CSToken *CSTokenFilterer) ParseApproval(log types.Log) (*CSTokenApproval, error) {
	event := new(CSTokenApproval)
	if err := _CSToken.contract.UnpackLog(event, "Approval", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenBurnIterator is returned from FilterBurn and is used to iterate over the raw logs and unpacked data for Burn events raised by the CSToken contract.
type CSTokenBurnIterator struct {
	Event *CSTokenBurn // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenBurnIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenBurn)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenBurn)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenBurnIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenBurnIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenBurn represents a Burn event raised by the CSToken contract.
type CSTokenBurn struct {
	From  common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterBurn is a free log retrieval operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed from, uint256 value)
func (_CSToken *CSTokenFilterer) FilterBurn(opts *bind.FilterOpts, from []common.Address) (*CSTokenBurnIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "Burn", fromRule)
	if err != nil {
		return nil, err
	}
	return &CSTokenBurnIterator{contract: _CSToken.contract, event: "Burn", logs: logs, sub: sub}, nil
}

// WatchBurn is a free log subscription operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed from, uint256 value)
func (_CSToken *CSTokenFilterer) WatchBurn(opts *bind.WatchOpts, sink chan<- *CSTokenBurn, from []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "Burn", fromRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenBurn)
				if err := _CSToken.contract.UnpackLog(event, "Burn", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseBurn is a log parse operation binding the contract event 0xcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5.
//
// Solidity: event Burn(address indexed from, uint256 value)
func (_CSToken *CSTokenFilterer) ParseBurn(log types.Log) (*CSTokenBurn, error) {
	event := new(CSTokenBurn)
	if err := _CSToken.contract.UnpackLog(event, "Burn", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenDestructionIterator is returned from FilterDestruction and is used to iterate over the raw logs and unpacked data for Destruction events raised by the CSToken contract.
type CSTokenDestructionIterator struct {
	Event *CSTokenDestruction // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenDestructionIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenDestruction)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenDestruction)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenDestructionIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenDestructionIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenDestruction represents a Destruction event raised by the CSToken contract.
type CSTokenDestruction struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterDestruction is a free log retrieval operation binding the contract event 0x9a1b418bc061a5d80270261562e6986a35d995f8051145f277be16103abd3453.
//
// Solidity: event Destruction(uint256 _amount)
func (_CSToken *CSTokenFilterer) FilterDestruction(opts *bind.FilterOpts) (*CSTokenDestructionIterator, error) {

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "Destruction")
	if err != nil {
		return nil, err
	}
	return &CSTokenDestructionIterator{contract: _CSToken.contract, event: "Destruction", logs: logs, sub: sub}, nil
}

// WatchDestruction is a free log subscription operation binding the contract event 0x9a1b418bc061a5d80270261562e6986a35d995f8051145f277be16103abd3453.
//
// Solidity: event Destruction(uint256 _amount)
func (_CSToken *CSTokenFilterer) WatchDestruction(opts *bind.WatchOpts, sink chan<- *CSTokenDestruction) (event.Subscription, error) {

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "Destruction")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenDestruction)
				if err := _CSToken.contract.UnpackLog(event, "Destruction", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseDestruction is a log parse operation binding the contract event 0x9a1b418bc061a5d80270261562e6986a35d995f8051145f277be16103abd3453.
//
// Solidity: event Destruction(uint256 _amount)
func (_CSToken *CSTokenFilterer) ParseDestruction(log types.Log) (*CSTokenDestruction, error) {
	event := new(CSTokenDestruction)
	if err := _CSToken.contract.UnpackLog(event, "Destruction", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenIssuanceIterator is returned from FilterIssuance and is used to iterate over the raw logs and unpacked data for Issuance events raised by the CSToken contract.
type CSTokenIssuanceIterator struct {
	Event *CSTokenIssuance // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenIssuanceIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenIssuance)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenIssuance)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenIssuanceIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenIssuanceIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenIssuance represents a Issuance event raised by the CSToken contract.
type CSTokenIssuance struct {
	Amount *big.Int
	Raw    types.Log // Blockchain specific contextual infos
}

// FilterIssuance is a free log retrieval operation binding the contract event 0x9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc3.
//
// Solidity: event Issuance(uint256 _amount)
func (_CSToken *CSTokenFilterer) FilterIssuance(opts *bind.FilterOpts) (*CSTokenIssuanceIterator, error) {

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "Issuance")
	if err != nil {
		return nil, err
	}
	return &CSTokenIssuanceIterator{contract: _CSToken.contract, event: "Issuance", logs: logs, sub: sub}, nil
}

// WatchIssuance is a free log subscription operation binding the contract event 0x9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc3.
//
// Solidity: event Issuance(uint256 _amount)
func (_CSToken *CSTokenFilterer) WatchIssuance(opts *bind.WatchOpts, sink chan<- *CSTokenIssuance) (event.Subscription, error) {

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "Issuance")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenIssuance)
				if err := _CSToken.contract.UnpackLog(event, "Issuance", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseIssuance is a log parse operation binding the contract event 0x9386c90217c323f58030f9dadcbc938f807a940f4ff41cd4cead9562f5da7dc3.
//
// Solidity: event Issuance(uint256 _amount)
func (_CSToken *CSTokenFilterer) ParseIssuance(log types.Log) (*CSTokenIssuance, error) {
	event := new(CSTokenIssuance)
	if err := _CSToken.contract.UnpackLog(event, "Issuance", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenNewSmartTokenIterator is returned from FilterNewSmartToken and is used to iterate over the raw logs and unpacked data for NewSmartToken events raised by the CSToken contract.
type CSTokenNewSmartTokenIterator struct {
	Event *CSTokenNewSmartToken // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenNewSmartTokenIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenNewSmartToken)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenNewSmartToken)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenNewSmartTokenIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenNewSmartTokenIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenNewSmartToken represents a NewSmartToken event raised by the CSToken contract.
type CSTokenNewSmartToken struct {
	Token common.Address
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterNewSmartToken is a free log retrieval operation binding the contract event 0xf4cd1f8571e8d9c97ffcb81558807ab73f9803d54de5da6a0420593c82a4a9f0.
//
// Solidity: event NewSmartToken(address _token)
func (_CSToken *CSTokenFilterer) FilterNewSmartToken(opts *bind.FilterOpts) (*CSTokenNewSmartTokenIterator, error) {

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "NewSmartToken")
	if err != nil {
		return nil, err
	}
	return &CSTokenNewSmartTokenIterator{contract: _CSToken.contract, event: "NewSmartToken", logs: logs, sub: sub}, nil
}

// WatchNewSmartToken is a free log subscription operation binding the contract event 0xf4cd1f8571e8d9c97ffcb81558807ab73f9803d54de5da6a0420593c82a4a9f0.
//
// Solidity: event NewSmartToken(address _token)
func (_CSToken *CSTokenFilterer) WatchNewSmartToken(opts *bind.WatchOpts, sink chan<- *CSTokenNewSmartToken) (event.Subscription, error) {

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "NewSmartToken")
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenNewSmartToken)
				if err := _CSToken.contract.UnpackLog(event, "NewSmartToken", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseNewSmartToken is a log parse operation binding the contract event 0xf4cd1f8571e8d9c97ffcb81558807ab73f9803d54de5da6a0420593c82a4a9f0.
//
// Solidity: event NewSmartToken(address _token)
func (_CSToken *CSTokenFilterer) ParseNewSmartToken(log types.Log) (*CSTokenNewSmartToken, error) {
	event := new(CSTokenNewSmartToken)
	if err := _CSToken.contract.UnpackLog(event, "NewSmartToken", log); err != nil {
		return nil, err
	}
	return event, nil
}

// CSTokenTransferIterator is returned from FilterTransfer and is used to iterate over the raw logs and unpacked data for Transfer events raised by the CSToken contract.
type CSTokenTransferIterator struct {
	Event *CSTokenTransfer // Event containing the contract specifics and raw log

	contract *bind.BoundContract // Generic contract to use for unpacking event data
	event    string              // Event name to use for unpacking event data

	logs chan types.Log        // Log channel receiving the found contract events
	sub  ethereum.Subscription // Subscription for errors, completion and termination
	done bool                  // Whether the subscription completed delivering logs
	fail error                 // Occurred error to stop iteration
}

// Next advances the iterator to the subsequent event, returning whether there
// are any more events found. In case of a retrieval or parsing error, false is
// returned and Error() can be queried for the exact failure.
func (it *CSTokenTransferIterator) Next() bool {
	// If the iterator failed, stop iterating
	if it.fail != nil {
		return false
	}
	// If the iterator completed, deliver directly whatever's available
	if it.done {
		select {
		case log := <-it.logs:
			it.Event = new(CSTokenTransfer)
			if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
				it.fail = err
				return false
			}
			it.Event.Raw = log
			return true

		default:
			return false
		}
	}
	// Iterator still in progress, wait for either a data or an error event
	select {
	case log := <-it.logs:
		it.Event = new(CSTokenTransfer)
		if err := it.contract.UnpackLog(it.Event, it.event, log); err != nil {
			it.fail = err
			return false
		}
		it.Event.Raw = log
		return true

	case err := <-it.sub.Err():
		it.done = true
		it.fail = err
		return it.Next()
	}
}

// Error returns any retrieval or parsing error occurred during filtering.
func (it *CSTokenTransferIterator) Error() error {
	return it.fail
}

// Close terminates the iteration process, releasing any pending underlying
// resources.
func (it *CSTokenTransferIterator) Close() error {
	it.sub.Unsubscribe()
	return nil
}

// CSTokenTransfer represents a Transfer event raised by the CSToken contract.
type CSTokenTransfer struct {
	From  common.Address
	To    common.Address
	Value *big.Int
	Raw   types.Log // Blockchain specific contextual infos
}

// FilterTransfer is a free log retrieval operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_CSToken *CSTokenFilterer) FilterTransfer(opts *bind.FilterOpts, from []common.Address, to []common.Address) (*CSTokenTransferIterator, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _CSToken.contract.FilterLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return &CSTokenTransferIterator{contract: _CSToken.contract, event: "Transfer", logs: logs, sub: sub}, nil
}

// WatchTransfer is a free log subscription operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_CSToken *CSTokenFilterer) WatchTransfer(opts *bind.WatchOpts, sink chan<- *CSTokenTransfer, from []common.Address, to []common.Address) (event.Subscription, error) {

	var fromRule []interface{}
	for _, fromItem := range from {
		fromRule = append(fromRule, fromItem)
	}
	var toRule []interface{}
	for _, toItem := range to {
		toRule = append(toRule, toItem)
	}

	logs, sub, err := _CSToken.contract.WatchLogs(opts, "Transfer", fromRule, toRule)
	if err != nil {
		return nil, err
	}
	return event.NewSubscription(func(quit <-chan struct{}) error {
		defer sub.Unsubscribe()
		for {
			select {
			case log := <-logs:
				// New log arrived, parse the event and forward to the user
				event := new(CSTokenTransfer)
				if err := _CSToken.contract.UnpackLog(event, "Transfer", log); err != nil {
					return err
				}
				event.Raw = log

				select {
				case sink <- event:
				case err := <-sub.Err():
					return err
				case <-quit:
					return nil
				}
			case err := <-sub.Err():
				return err
			case <-quit:
				return nil
			}
		}
	}), nil
}

// ParseTransfer is a log parse operation binding the contract event 0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef.
//
// Solidity: event Transfer(address indexed from, address indexed to, uint256 value)
func (_CSToken *CSTokenFilterer) ParseTransfer(log types.Log) (*CSTokenTransfer, error) {
	event := new(CSTokenTransfer)
	if err := _CSToken.contract.UnpackLog(event, "Transfer", log); err != nil {
		return nil, err
	}
	return event, nil
}

// UtilsABI is the input ABI used to generate the binding from.
const UtilsABI = "[{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]"

// UtilsBin is the compiled bytecode used for deploying new contracts.
var UtilsBin = "0x6080604052348015600f57600080fd5b50603580601d6000396000f3006080604052600080fd00a165627a7a723058201af604620c1b60bf554efd3acf006606ef794fe88d996e025db4d31512b86f060029"

// DeployUtils deploys a new Ethereum contract, binding an instance of Utils to it.
func DeployUtils(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Utils, error) {
	parsed, err := abi.JSON(strings.NewReader(UtilsABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(UtilsBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// Utils is an auto generated Go binding around an Ethereum contract.
type Utils struct {
	UtilsCaller     // Read-only binding to the contract
	UtilsTransactor // Write-only binding to the contract
	UtilsFilterer   // Log filterer for contract events
}

// UtilsCaller is an auto generated read-only Go binding around an Ethereum contract.
type UtilsCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsTransactor is an auto generated write-only Go binding around an Ethereum contract.
type UtilsTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type UtilsFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// UtilsSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type UtilsSession struct {
	Contract     *Utils            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type UtilsCallerSession struct {
	Contract *UtilsCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// UtilsTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type UtilsTransactorSession struct {
	Contract     *UtilsTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// UtilsRaw is an auto generated low-level Go binding around an Ethereum contract.
type UtilsRaw struct {
	Contract *Utils // Generic contract binding to access the raw methods on
}

// UtilsCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type UtilsCallerRaw struct {
	Contract *UtilsCaller // Generic read-only contract binding to access the raw methods on
}

// UtilsTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type UtilsTransactorRaw struct {
	Contract *UtilsTransactor // Generic write-only contract binding to access the raw methods on
}

// NewUtils creates a new instance of Utils, bound to a specific deployed contract.
func NewUtils(address common.Address, backend bind.ContractBackend) (*Utils, error) {
	contract, err := bindUtils(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Utils{UtilsCaller: UtilsCaller{contract: contract}, UtilsTransactor: UtilsTransactor{contract: contract}, UtilsFilterer: UtilsFilterer{contract: contract}}, nil
}

// NewUtilsCaller creates a new read-only instance of Utils, bound to a specific deployed contract.
func NewUtilsCaller(address common.Address, caller bind.ContractCaller) (*UtilsCaller, error) {
	contract, err := bindUtils(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsCaller{contract: contract}, nil
}

// NewUtilsTransactor creates a new write-only instance of Utils, bound to a specific deployed contract.
func NewUtilsTransactor(address common.Address, transactor bind.ContractTransactor) (*UtilsTransactor, error) {
	contract, err := bindUtils(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &UtilsTransactor{contract: contract}, nil
}

// NewUtilsFilterer creates a new log filterer instance of Utils, bound to a specific deployed contract.
func NewUtilsFilterer(address common.Address, filterer bind.ContractFilterer) (*UtilsFilterer, error) {
	contract, err := bindUtils(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &UtilsFilterer{contract: contract}, nil
}

// bindUtils binds a generic wrapper to an already deployed contract.
func bindUtils(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(UtilsABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.UtilsCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.UtilsTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Utils *UtilsCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Utils.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Utils *UtilsTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Utils *UtilsTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Utils.Contract.contract.Transact(opts, method, params...)
}

// OwnedABI is the input ABI used to generate the binding from.
const OwnedABI = "[{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]"

// OwnedFuncSigs maps the 4-byte function signature to its string representation.
var OwnedFuncSigs = map[string]string{
	"a6f9dae1": "changeOwner(address)",
	"8da5cb5b": "owner()",
}

// OwnedBin is the compiled bytecode used for deploying new contracts.
var OwnedBin = "0x608060405234801561001057600080fd5b5060008054600160a060020a03191633179055610166806100326000396000f30060806040526004361061004b5763ffffffff7c01000000000000000000000000000000000000000000000000000000006000350416638da5cb5b8114610050578063a6f9dae11461008e575b600080fd5b34801561005c57600080fd5b506100656100be565b6040805173ffffffffffffffffffffffffffffffffffffffff9092168252519081900360200190f35b34801561009a57600080fd5b506100bc73ffffffffffffffffffffffffffffffffffffffff600435166100da565b005b60005473ffffffffffffffffffffffffffffffffffffffff1681565b60005473ffffffffffffffffffffffffffffffffffffffff1633146100fe57600080fd5b6000805473ffffffffffffffffffffffffffffffffffffffff191673ffffffffffffffffffffffffffffffffffffffff929092169190911790555600a165627a7a7230582043b6a4a1b5199f2c4e330003372985e7fb4a5482152db0557a764268439f717d0029"

// DeployOwned deploys a new Ethereum contract, binding an instance of Owned to it.
func DeployOwned(auth *bind.TransactOpts, backend bind.ContractBackend) (common.Address, *types.Transaction, *Owned, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnedABI))
	if err != nil {
		return common.Address{}, nil, nil, err
	}

	address, tx, contract, err := bind.DeployContract(auth, parsed, common.FromHex(OwnedBin), backend)
	if err != nil {
		return common.Address{}, nil, nil, err
	}
	return address, tx, &Owned{OwnedCaller: OwnedCaller{contract: contract}, OwnedTransactor: OwnedTransactor{contract: contract}, OwnedFilterer: OwnedFilterer{contract: contract}}, nil
}

// Owned is an auto generated Go binding around an Ethereum contract.
type Owned struct {
	OwnedCaller     // Read-only binding to the contract
	OwnedTransactor // Write-only binding to the contract
	OwnedFilterer   // Log filterer for contract events
}

// OwnedCaller is an auto generated read-only Go binding around an Ethereum contract.
type OwnedCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnedTransactor is an auto generated write-only Go binding around an Ethereum contract.
type OwnedTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnedFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type OwnedFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// OwnedSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type OwnedSession struct {
	Contract     *Owned            // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnedCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type OwnedCallerSession struct {
	Contract *OwnedCaller  // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts // Call options to use throughout this session
}

// OwnedTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type OwnedTransactorSession struct {
	Contract     *OwnedTransactor  // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// OwnedRaw is an auto generated low-level Go binding around an Ethereum contract.
type OwnedRaw struct {
	Contract *Owned // Generic contract binding to access the raw methods on
}

// OwnedCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type OwnedCallerRaw struct {
	Contract *OwnedCaller // Generic read-only contract binding to access the raw methods on
}

// OwnedTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type OwnedTransactorRaw struct {
	Contract *OwnedTransactor // Generic write-only contract binding to access the raw methods on
}

// NewOwned creates a new instance of Owned, bound to a specific deployed contract.
func NewOwned(address common.Address, backend bind.ContractBackend) (*Owned, error) {
	contract, err := bindOwned(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &Owned{OwnedCaller: OwnedCaller{contract: contract}, OwnedTransactor: OwnedTransactor{contract: contract}, OwnedFilterer: OwnedFilterer{contract: contract}}, nil
}

// NewOwnedCaller creates a new read-only instance of Owned, bound to a specific deployed contract.
func NewOwnedCaller(address common.Address, caller bind.ContractCaller) (*OwnedCaller, error) {
	contract, err := bindOwned(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &OwnedCaller{contract: contract}, nil
}

// NewOwnedTransactor creates a new write-only instance of Owned, bound to a specific deployed contract.
func NewOwnedTransactor(address common.Address, transactor bind.ContractTransactor) (*OwnedTransactor, error) {
	contract, err := bindOwned(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &OwnedTransactor{contract: contract}, nil
}

// NewOwnedFilterer creates a new log filterer instance of Owned, bound to a specific deployed contract.
func NewOwnedFilterer(address common.Address, filterer bind.ContractFilterer) (*OwnedFilterer, error) {
	contract, err := bindOwned(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &OwnedFilterer{contract: contract}, nil
}

// bindOwned binds a generic wrapper to an already deployed contract.
func bindOwned(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(OwnedABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Owned *OwnedRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Owned.Contract.OwnedCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Owned *OwnedRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Owned.Contract.OwnedTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Owned *OwnedRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Owned.Contract.OwnedTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_Owned *OwnedCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _Owned.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_Owned *OwnedTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _Owned.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_Owned *OwnedTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _Owned.Contract.contract.Transact(opts, method, params...)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Owned *OwnedCaller) Owner(opts *bind.CallOpts) (common.Address, error) {
	var (
		ret0 = new(common.Address)
	)
	out := ret0
	err := _Owned.contract.Call(opts, out, "owner")
	return *ret0, err
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Owned *OwnedSession) Owner() (common.Address, error) {
	return _Owned.Contract.Owner(&_Owned.CallOpts)
}

// Owner is a free data retrieval call binding the contract method 0x8da5cb5b.
//
// Solidity: function owner() constant returns(address)
func (_Owned *OwnedCallerSession) Owner() (common.Address, error) {
	return _Owned.Contract.Owner(&_Owned.CallOpts)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_Owned *OwnedTransactor) ChangeOwner(opts *bind.TransactOpts, newOwner common.Address) (*types.Transaction, error) {
	return _Owned.contract.Transact(opts, "changeOwner", newOwner)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_Owned *OwnedSession) ChangeOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Owned.Contract.ChangeOwner(&_Owned.TransactOpts, newOwner)
}

// ChangeOwner is a paid mutator transaction binding the contract method 0xa6f9dae1.
//
// Solidity: function changeOwner(address newOwner) returns()
func (_Owned *OwnedTransactorSession) ChangeOwner(newOwner common.Address) (*types.Transaction, error) {
	return _Owned.Contract.ChangeOwner(&_Owned.TransactOpts, newOwner)
}

// TokenRecipientABI is the input ABI used to generate the binding from.
const TokenRecipientABI = "[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]"

// TokenRecipientFuncSigs maps the 4-byte function signature to its string representation.
var TokenRecipientFuncSigs = map[string]string{
	"8f4ffcb1": "receiveApproval(address,uint256,address,bytes)",
}

// TokenRecipient is an auto generated Go binding around an Ethereum contract.
type TokenRecipient struct {
	TokenRecipientCaller     // Read-only binding to the contract
	TokenRecipientTransactor // Write-only binding to the contract
	TokenRecipientFilterer   // Log filterer for contract events
}

// TokenRecipientCaller is an auto generated read-only Go binding around an Ethereum contract.
type TokenRecipientCaller struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenRecipientTransactor is an auto generated write-only Go binding around an Ethereum contract.
type TokenRecipientTransactor struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenRecipientFilterer is an auto generated log filtering Go binding around an Ethereum contract events.
type TokenRecipientFilterer struct {
	contract *bind.BoundContract // Generic contract wrapper for the low level calls
}

// TokenRecipientSession is an auto generated Go binding around an Ethereum contract,
// with pre-set call and transact options.
type TokenRecipientSession struct {
	Contract     *TokenRecipient   // Generic contract binding to set the session for
	CallOpts     bind.CallOpts     // Call options to use throughout this session
	TransactOpts bind.TransactOpts // Transaction auth options to use throughout this session
}

// TokenRecipientCallerSession is an auto generated read-only Go binding around an Ethereum contract,
// with pre-set call options.
type TokenRecipientCallerSession struct {
	Contract *TokenRecipientCaller // Generic contract caller binding to set the session for
	CallOpts bind.CallOpts         // Call options to use throughout this session
}

// TokenRecipientTransactorSession is an auto generated write-only Go binding around an Ethereum contract,
// with pre-set transact options.
type TokenRecipientTransactorSession struct {
	Contract     *TokenRecipientTransactor // Generic contract transactor binding to set the session for
	TransactOpts bind.TransactOpts         // Transaction auth options to use throughout this session
}

// TokenRecipientRaw is an auto generated low-level Go binding around an Ethereum contract.
type TokenRecipientRaw struct {
	Contract *TokenRecipient // Generic contract binding to access the raw methods on
}

// TokenRecipientCallerRaw is an auto generated low-level read-only Go binding around an Ethereum contract.
type TokenRecipientCallerRaw struct {
	Contract *TokenRecipientCaller // Generic read-only contract binding to access the raw methods on
}

// TokenRecipientTransactorRaw is an auto generated low-level write-only Go binding around an Ethereum contract.
type TokenRecipientTransactorRaw struct {
	Contract *TokenRecipientTransactor // Generic write-only contract binding to access the raw methods on
}

// NewTokenRecipient creates a new instance of TokenRecipient, bound to a specific deployed contract.
func NewTokenRecipient(address common.Address, backend bind.ContractBackend) (*TokenRecipient, error) {
	contract, err := bindTokenRecipient(address, backend, backend, backend)
	if err != nil {
		return nil, err
	}
	return &TokenRecipient{TokenRecipientCaller: TokenRecipientCaller{contract: contract}, TokenRecipientTransactor: TokenRecipientTransactor{contract: contract}, TokenRecipientFilterer: TokenRecipientFilterer{contract: contract}}, nil
}

// NewTokenRecipientCaller creates a new read-only instance of TokenRecipient, bound to a specific deployed contract.
func NewTokenRecipientCaller(address common.Address, caller bind.ContractCaller) (*TokenRecipientCaller, error) {
	contract, err := bindTokenRecipient(address, caller, nil, nil)
	if err != nil {
		return nil, err
	}
	return &TokenRecipientCaller{contract: contract}, nil
}

// NewTokenRecipientTransactor creates a new write-only instance of TokenRecipient, bound to a specific deployed contract.
func NewTokenRecipientTransactor(address common.Address, transactor bind.ContractTransactor) (*TokenRecipientTransactor, error) {
	contract, err := bindTokenRecipient(address, nil, transactor, nil)
	if err != nil {
		return nil, err
	}
	return &TokenRecipientTransactor{contract: contract}, nil
}

// NewTokenRecipientFilterer creates a new log filterer instance of TokenRecipient, bound to a specific deployed contract.
func NewTokenRecipientFilterer(address common.Address, filterer bind.ContractFilterer) (*TokenRecipientFilterer, error) {
	contract, err := bindTokenRecipient(address, nil, nil, filterer)
	if err != nil {
		return nil, err
	}
	return &TokenRecipientFilterer{contract: contract}, nil
}

// bindTokenRecipient binds a generic wrapper to an already deployed contract.
func bindTokenRecipient(address common.Address, caller bind.ContractCaller, transactor bind.ContractTransactor, filterer bind.ContractFilterer) (*bind.BoundContract, error) {
	parsed, err := abi.JSON(strings.NewReader(TokenRecipientABI))
	if err != nil {
		return nil, err
	}
	return bind.NewBoundContract(address, parsed, caller, transactor, filterer), nil
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenRecipient *TokenRecipientRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenRecipient.Contract.TokenRecipientCaller.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenRecipient *TokenRecipientRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenRecipient.Contract.TokenRecipientTransactor.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenRecipient *TokenRecipientRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenRecipient.Contract.TokenRecipientTransactor.contract.Transact(opts, method, params...)
}

// Call invokes the (constant) contract method with params as input values and
// sets the output to result. The result type might be a single field for simple
// returns, a slice of interfaces for anonymous returns and a struct for named
// returns.
func (_TokenRecipient *TokenRecipientCallerRaw) Call(opts *bind.CallOpts, result interface{}, method string, params ...interface{}) error {
	return _TokenRecipient.Contract.contract.Call(opts, result, method, params...)
}

// Transfer initiates a plain transaction to move funds to the contract, calling
// its default method if one is available.
func (_TokenRecipient *TokenRecipientTransactorRaw) Transfer(opts *bind.TransactOpts) (*types.Transaction, error) {
	return _TokenRecipient.Contract.contract.Transfer(opts)
}

// Transact invokes the (paid) contract method with params as input values.
func (_TokenRecipient *TokenRecipientTransactorRaw) Transact(opts *bind.TransactOpts, method string, params ...interface{}) (*types.Transaction, error) {
	return _TokenRecipient.Contract.contract.Transact(opts, method, params...)
}

// ReceiveApproval is a paid mutator transaction binding the contract method 0x8f4ffcb1.
//
// Solidity: function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) returns()
func (_TokenRecipient *TokenRecipientTransactor) ReceiveApproval(opts *bind.TransactOpts, _from common.Address, _value *big.Int, _token common.Address, _extraData []byte) (*types.Transaction, error) {
	return _TokenRecipient.contract.Transact(opts, "receiveApproval", _from, _value, _token, _extraData)
}

// ReceiveApproval is a paid mutator transaction binding the contract method 0x8f4ffcb1.
//
// Solidity: function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) returns()
func (_TokenRecipient *TokenRecipientSession) ReceiveApproval(_from common.Address, _value *big.Int, _token common.Address, _extraData []byte) (*types.Transaction, error) {
	return _TokenRecipient.Contract.ReceiveApproval(&_TokenRecipient.TransactOpts, _from, _value, _token, _extraData)
}

// ReceiveApproval is a paid mutator transaction binding the contract method 0x8f4ffcb1.
//
// Solidity: function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) returns()
func (_TokenRecipient *TokenRecipientTransactorSession) ReceiveApproval(_from common.Address, _value *big.Int, _token common.Address, _extraData []byte) (*types.Transaction, error) {
	return _TokenRecipient.Contract.ReceiveApproval(&_TokenRecipient.TransactOpts, _from, _value, _token, _extraData)
}
